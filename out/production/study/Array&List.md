Array
- 메모리의 연속 공간에 값이 채워져 있는 형태의 자료 구조
- 배열의 값은 인덱스를 통해 참조가 가능
- 선언 시 크기가 고정되며, 이후 변경 불가능

- 장점
  - 빠른 접근 속도: 인덱스를 통한 직접 접근으로 O(1)의 시간 복잡도
  - 메모리 효율성: 연속된 메모리 공간 사용으로 캐시 효율성이 높음
   -간단한 구조: 구현과 사용이 직관적

- 단점
  - 고정된 크기: 선언 후 크기 변경 불가능, 공간 낭비 또는 부족 문제 발생 가능
  - 삽입/삭제의 비효율성:
  - 중간에 데이터 삽입 시 뒤의 모든 요소를 이동시켜야 함 (O(n))
  - 삭제 시에도 빈 공간을 채우기 위해 요소 이동 필요 (O(n))
  - 메모리 재할당 불가: 크기 확장이 필요하면 새로운 배열을 생성하고 복사해야 함
---
List
- 값과 포인터를 묶은 형태로 각 노드이 포인터로 노드를 연결한 자료구조

- 종류
  - ArrayList 
    - 내부적으로 배열을 사용하지만, 크기가 자동으로 조정.

  - LinkedList
    - 각 노드가 다음 노드의 주소를 가리키는 포인터로 연결
 
  - Vector
  
  - Stack
---
Array 와 List를 비교

- Array는 한번 선언한 크기를 늘릴 수 없다.(고정적)
- List의 크기는 정해져 있지 않다. (가변적)

- Array는 값을 삭제하거나, 추가하기가 어렵다. => 이동이 필요하다.
- List는 pointer 연결로 인해 데이터를 삭제, 추가하기가 용이하다.
---
- Array 사용이 적합한 경우
  - 데이터의 크기가 고정되어 있고 변하지 않을 때
  - 데이터에 대한 빠른 인덱스 접근이 빈번할 때
  - 메모리 효율이 중요하고 추가 공간을 최소화하고 싶을 때
  - ex) 고정된 크기의 좌표 배열, 월별 데이터(12개), 요일 데이터(7개)
---
- ArrayList 사용이 적합한 경우
  - 데이터 크기가 가변적이지만, 조회가 빈번한 경우
  - 주로 끝에 데이터를 추가하거나 삭제하는 경우
  - 인덱스를 통한 빠른 접근이 필요한 경우
  - ex) 검색 결과 목록, 데이터베이스 조회 결과
---
- LinkedList 사용이 적합한 경우
  - 데이터의 삽입/삭제가 빈번한 경우
  - 중간 위치에서의 삽입/삭제가 많은 경우
  - 데이터 크기를 예측하기 어려운 경우
  - ex) 대기열(Queue), 실행 취소/다시 실행 기능, 플레이리스트
---